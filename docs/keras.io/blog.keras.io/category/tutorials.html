<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from blog.keras.io/category/tutorials.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 13 Jun 2018 14:17:35 GMT -->
<head>
        <title>The Keras Blog - Tutorials</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="../theme/css/main.css" type="text/css" />
        <link rel="stylesheet" href="../theme/css/pygment.css" type="text/css" />

        <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Source+Sans+Pro:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css">
        <link href="../index.html" type="application/atom+xml" rel="alternate" title="The Keras Blog ATOM Feed" />


        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="//blog.keras.io/css/ie.css"/>
                <script src="//blog.keras.io/js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="//blog.keras.io/css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1>
                    <a href="../index-2.html">The Keras Blog </a>
                </h1>
                <p id="side">
                    <a href="https://github.com/fchollet/keras">Keras</a> is a Deep Learning library for Python, that is simple, modular, and extensible.
                </p>
                <nav><ul>
                <li><a href="../index.html">Archives</a></li>
                    <li >
                        <a href="https://github.com/fchollet/keras">Github</a>
                    </li>
                    <li >
                        <a href="../../keras.io/index.html">Documentation</a>
                    </li>
                    <li >
                        <a href="https://groups.google.com/forum/#!forum/keras-users">Google Group</a>
                    </li>
                </ul></nav>
        </header><!-- /#banner -->

     <section id="content" class="body">
        <aside id="featured"><article>
                <h1 class="entry-title"><a href="../building-a-simple-keras-deep-learning-rest-api.html">Building a simple Keras + deep learning REST API</a></h1>
<footer class="post-info">
        <abbr class="published" title="2018-01-29T00:00:00+01:00">
                Mon 29 January 2018
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="../author/adrian-rosebrock.html">Adrian Rosebrock</a>
        </address>
<p>In <a href="tutorials.html">Tutorials</a>. </p>
</p></footer><!-- /.post-info --><!-- /.post-info -->
                <p><em>This is a guest post by Adrian Rosebrock. Adrian is the author of <a href="https://www.pyimagesearch.com/">PyImageSearch.com</a>,
a blog about computer vision and deep learning. Adrian recently finished authoring</em>
<a href="https://www.pyimagesearch.com/deep-learning-computer-vision-python-book/">Deep Learning for Computer Vision with Python</a><em>,
a new book on deep learning for computer vision and image recognition using Keras.</em></p>
<hr />
<p>In this tutorial, we will present a simple method to take a Keras model and deploy it as a REST API.</p>
<p>The examples covered in this post will serve as a template/starting point for building your own deep
 learning APIs &mdash; you will be able to extend the code and customize it based on how scalable
 and robust your API endpoint needs to be.</p>
<p>Specifically, we will learn:</p>
<ul>
<li>How to (and how not to) load a Keras model into memory so it can be efficiently used for inference</li>
<li>How to use the Flask web framework to create an endpoint for our API</li>
<li>How to make predictions using our model, JSON-ify them, and return the results to the client</li>
<li>How to call our Keras REST API using both cURL and Python</li>
</ul>
<p>By the end of this tutorial you'll have a good understanding of the components (in their simplest
form) that go into a creating Keras REST API.</p>
<p>Feel free to use the code presented in this guide as a starting point for your own deep learning
REST API.</p>
<p><strong>Note: The method covered here is intended to be instructional. It is <em>not</em> meant to be
production-level and capable of scaling under heavy load. If you're interested in a more advanced
Keras REST API that leverages message queues and batching, <a href="https://www.pyimagesearch.com/2018/01/29/scalable-keras-deep-learning-rest-api/">please refer to this tutorial</a>.</strong></p>
<hr />
<h2>Configuring your development environment</h2>
<p>We'll be making the assumption that Keras is already configured and installed on your machine.
If not, please ensure you install Keras using the <a href="../../keras.io/index.html#installation">official install instructions</a>.</p>
<p>From there, we'll need to install <a href="http://flask.pocoo.org/">Flask</a> (and its associated
dependencies), a Python web framework, so we can build our API endpoint. We'll also need
<a href="http://docs.python-requests.org/en/master/">requests</a> so we can consume our API as well.</p>
<p>The relevant <code>pip</code> install commands are listed below:</p>
<div class="highlight"><pre><span></span>$ pip install flask gevent requests pillow
</pre></div>


<hr />
<h2>Building your Keras REST API</h2>
<p>Our Keras REST API is self-contained in a single file named <code>run_keras_server.py</code>. We kept the
installation in a single file as a manner of simplicity &mdash; the implementation can be easily
modularized as well.</p>
<p>Inside <code>run_keras_server.py</code> you'll find three functions, namely:</p>
<ul>
<li><code>load_model</code>: Used to load our trained Keras model and prepare it for inference.</li>
<li><code>prepare_image</code>: This function preprocesses an input image prior to passing it through our
 network for prediction. If you are not working with image data you may want to consider changing
 the name to a more generic <code>prepare_datapoint</code> and applying any scaling/normalization you may need.</li>
<li><code>predict</code>: The actual endpoint of our API that will classify the incoming data from the request
and return the results to the client.</li>
</ul>
<p>The full code to this tutorial can be found <a href="https://github.com/jrosebr1/simple-keras-rest-api">here</a>.</p>
<div class="highlight"><pre><span></span><span class="c1"># import the necessary packages</span>
<span class="kn">from</span> <span class="nn">keras.applications</span> <span class="kn">import</span> <span class="n">ResNet50</span>
<span class="kn">from</span> <span class="nn">keras.preprocessing.image</span> <span class="kn">import</span> <span class="n">img_to_array</span>
<span class="kn">from</span> <span class="nn">keras.applications</span> <span class="kn">import</span> <span class="n">imagenet_utils</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">flask</span>
<span class="kn">import</span> <span class="nn">io</span>

<span class="c1"># initialize our Flask application and the Keras model</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">flask</span><span class="o">.</span><span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>


<p>Our first code snippet handles importing our required packages and initializing both the Flask
application and our <code>model</code>.</p>
<p>From there we define the <code>load_model</code> function:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_model</span><span class="p">():</span>
    <span class="c1"># load the pre-trained Keras model (here we are using a model</span>
    <span class="c1"># pre-trained on ImageNet and provided by Keras, but you can</span>
    <span class="c1"># substitute in your own networks just as easily)</span>
    <span class="k">global</span> <span class="n">model</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ResNet50</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="s2">&quot;imagenet&quot;</span><span class="p">)</span>
</pre></div>


<p>As the name suggests, this method is responsible for instantiating our architecture and loading our
weights from disk.</p>
<p>For the sake of simplicity, we'll be utilizing the ResNet50 architecture which has been pre-trained
on the ImageNet dataset.</p>
<p>If you're using your own custom model you'll want to modify this function to load your
architecture + weights from disk.</p>
<p>Before we can perform prediction on any data coming from our client we first need to prepare and
preprocess the data:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">prepare_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="c1"># if the image mode is not RGB, convert it</span>
    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;RGB&quot;</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;RGB&quot;</span><span class="p">)</span>

    <span class="c1"># resize the input image and preprocess it</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">img_to_array</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">imagenet_utils</span><span class="o">.</span><span class="n">preprocess_input</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

    <span class="c1"># return the processed image</span>
    <span class="k">return</span> <span class="n">image</span>
</pre></div>


<p>This function:</p>
<ul>
<li>Accepts an input image</li>
<li>Converts the mode to RGB (if necessary)</li>
<li>Resizes it to 224x224 pixels (the input spatial dimensions for ResNet)</li>
<li>Preprocesses the array via mean subtraction and scaling</li>
</ul>
<p>Again, you should modify this function based on any preprocessing, scaling, and/or normalization
you need prior to passing the input data through the model.</p>
<p>We are now ready to define the <code>predict</code> function &mdash; this method processes any requests to the
<code>/predict</code> endpoint:</p>
<div class="highlight"><pre><span></span><span class="nd">@app.route</span><span class="p">(</span><span class="s2">&quot;/predict&quot;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;POST&quot;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">predict</span><span class="p">():</span>
    <span class="c1"># initialize the data dictionary that will be returned from the</span>
    <span class="c1"># view</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;success&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">}</span>

    <span class="c1"># ensure an image was properly uploaded to our endpoint</span>
    <span class="k">if</span> <span class="n">flask</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;POST&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flask</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;image&quot;</span><span class="p">):</span>
            <span class="c1"># read the image in PIL format</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">flask</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>

            <span class="c1"># preprocess the image and prepare it for classification</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">prepare_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">))</span>

            <span class="c1"># classify the input image and then initialize the list</span>
            <span class="c1"># of predictions to return to the client</span>
            <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">imagenet_utils</span><span class="o">.</span><span class="n">decode_predictions</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;predictions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># loop over the results and add them to the list of</span>
            <span class="c1"># returned predictions</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">imagenetID</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">label</span><span class="p">,</span> <span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">prob</span><span class="p">)}</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;predictions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

            <span class="c1"># indicate that the request was a success</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c1"># return the data dictionary as a JSON response</span>
    <span class="k">return</span> <span class="n">flask</span><span class="o">.</span><span class="n">jsonify</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>


<p>The <code>data</code> dictionary is used to store any data that we want to return to the client. Right now
this includes a boolean used to indicate if prediction was successful or not &mdash; we'll also use
this dictionary to store the results of any predictions we make on the incoming data.</p>
<p>To accept the incoming data we check if:</p>
<ul>
<li>The request method is POST (enabling us to send arbitrary data to the endpoint, including images,
 JSON, encoded-data, etc.)</li>
<li>An <code>image</code> has been passed into the <code>files</code> attribute during the POST</li>
</ul>
<p>We then take the incoming data and:</p>
<ul>
<li>Read it in PIL format</li>
<li>Preprocess it</li>
<li>Pass it through our network</li>
<li>Loop over the results and add them individually to the <code>data["predictions"]</code> list</li>
<li>Return the response to the client in JSON format</li>
</ul>
<p>If you're working with non-image data you should remove the <code>request.files</code> code and either parse
the raw input data yourself or utilize <code>request.get_json()</code> to automatically parse the input data
to a Python dictionary/object. Additionally, consider giving <a href="https://scotch.io/bar-talk/processing-incoming-request-data-in-flask">following tutorial</a>
a read which discusses the fundamentals of Flask's <code>request object</code>.</p>
<p>All that's left to do now is launch our service:</p>
<div class="highlight"><pre><span></span><span class="c1"># if this is the main thread of execution first load the model and</span>
<span class="c1"># then start the server</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="k">print</span><span class="p">((</span><span class="s2">&quot;* Loading Keras model and Flask starting server...&quot;</span>
        <span class="s2">&quot;please wait until server has fully started&quot;</span><span class="p">))</span>
    <span class="n">load_model</span><span class="p">()</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>


<p>First we call <code>load_model</code> which loads our Keras model from disk.</p>
<p>The call to <code>load_model</code> is a blocking operation and prevents the web service from starting until
the model is fully loaded. Had we not ensured the model is fully loaded into memory and ready for
inference prior to starting the web service we could run into a situation where:</p>
<ol>
<li>A request is POST'ed to the server.</li>
<li>The server accepts the request, preprocesses the data, and then attempts to pass it into the model</li>
<li><em>...but since the model isn't fully loaded yet, our script will error out!</em></li>
</ol>
<p>When building your own Keras REST APIs, ensure logic is inserted to guarantee your model is loaded
and ready for inference <em>prior</em> to accepting requests.</p>
<hr />
<h2>How to <em>not</em> load a Keras model in a REST API</h2>
<p>You may be tempted to load your model <em>inside</em> your <code>predict</code> function, like so:</p>
<div class="highlight"><pre><span></span><span class="o">...</span>
    <span class="c1"># ensure an image was properly uploaded to our endpoint</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;POST&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;image&quot;</span><span class="p">):</span>
            <span class="c1"># read the image in PIL format</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>

            <span class="c1"># preprocess the image and prepare it for classification</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">prepare_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">))</span>

            <span class="c1"># load the model</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">ResNet50</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="s2">&quot;imagenet&quot;</span><span class="p">)</span>

            <span class="c1"># classify the input image and then initialize the list</span>
            <span class="c1"># of predictions to return to the client</span>
            <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">imagenet_utils</span><span class="o">.</span><span class="n">decode_predictions</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;predictions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">...</span>
</pre></div>


<p>This code implies that the <code>model</code> will be loaded <em>each and every time</em> a new request comes in.
This is incredibly inefficient and can even cause your system to run out of memory.</p>
<p>If you try to run the code above you'll notice that your API will run considerably slower
(especially if your model is large) &mdash; this is due to the <em>significant</em> overhead in both I/O
and CPU operations used to load your model for <em>each new request</em>.</p>
<p>To see how this can easily overwhelm your server's memory, let's suppose we have <em>N</em> incoming
requests to our server at the same time. This implies there will be <em>N</em> models loaded into
memory...again, at the same time. If your model is large, such as ResNet, storing <em>N</em> copies of the
model in RAM could easily exhaust the system memory.</p>
<p>To this end, try to avoid loading a new model instance for every new incoming request unless you
have a very specific, justifiable reason for doing so.</p>
<p><strong>Caveat:</strong> We are assuming you are using the default Flask server that is single threaded. If you
deploy to a multi-threaded server you could be in a situation where you are <em>still</em> loading
multiple models in memory even when using the "more correct" method discussed earlier in this post.
If you intend on using a dedicated server such as Apache or nginx you should consider making
your pipeline more scalable, <a href="https://www.pyimagesearch.com/2018/01/29/scalable-keras-deep-learning-rest-api/">as discussed here</a>.</p>
<hr />
<h2>Starting your Keras Rest API</h2>
<p>Starting the Keras REST API service is easy.</p>
<p>Open up a terminal and execute:</p>
<div class="highlight"><pre><span></span>$ python run_keras_server.py
Using TensorFlow backend.
 * Loading Keras model and Flask starting server...please <span class="nb">wait</span> <span class="k">until</span> server has fully started
...
 * Running on http://127.0.0.1:5000
</pre></div>


<p>As you can see from the output, our model is loaded <em>first</em> &mdash; after which we can start our
Flask server.</p>
<p>You can now access the server via <code>http://127.0.0.1:5000</code>.</p>
<p>However, if you were to copy and paste the IP address + port into your browser you would see the
following image:</p>
<p><img alt="keras api 404" src="img/simple-keras-rest-api/keras_api_404.html" /></p>
<p>The reason for this is because there is no index/homepage set in the Flask URLs routes.</p>
<p>Instead, try to access the <code>/predict</code> endpoint via your browser:</p>
<p><img alt="keras api 404" src="img/simple-keras-rest-api/keras_api_method_not_allowed.html" /></p>
<p>And you'll see a "Method Not Allowed" error. This error is due to the fact that your browser is
performing a GET request, but <code>/predict</code> only accepts a POST (which we'll demonstrate how to
perform in the next section).</p>
<hr />
<h2>Using cURL to test the Keras REST API</h2>
<p>When testing and debugging your Keras REST API, consider using <a href="https://curl.haxx.se/">cURL</a>
(which is a good tool to learn how to use, regardless).</p>
<p>Below you can see the image we wish to classify, a <em>dog</em>, but more specifically a <em>beagle</em>:</p>
<p><img alt="dog" src="img/simple-keras-rest-api/dog.html" /></p>
<p>We can use <code>curl</code> to pass this image to our API and find out what ResNet thinks the image contains:</p>
<div class="highlight"><pre><span></span>$ curl -X POST -F <span class="nv">image</span><span class="o">=</span>@dog.jpg <span class="s1">&#39;http://localhost:5000/predict&#39;</span>
<span class="o">{</span>
  <span class="s2">&quot;predictions&quot;</span>: <span class="o">[</span>
    <span class="o">{</span>
      <span class="s2">&quot;label&quot;</span>: <span class="s2">&quot;beagle&quot;</span>,
      <span class="s2">&quot;probability&quot;</span>: 0.9901360869407654
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">&quot;label&quot;</span>: <span class="s2">&quot;Walker_hound&quot;</span>,
      <span class="s2">&quot;probability&quot;</span>: 0.002396771451458335
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">&quot;label&quot;</span>: <span class="s2">&quot;pot&quot;</span>,
      <span class="s2">&quot;probability&quot;</span>: 0.0013951235450804234
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">&quot;label&quot;</span>: <span class="s2">&quot;Brittany_spaniel&quot;</span>,
      <span class="s2">&quot;probability&quot;</span>: 0.001283277408219874
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">&quot;label&quot;</span>: <span class="s2">&quot;bluetick&quot;</span>,
      <span class="s2">&quot;probability&quot;</span>: 0.0010894243605434895
    <span class="o">}</span>
  <span class="o">]</span>,
  <span class="s2">&quot;success&quot;</span>: <span class="nb">true</span>
<span class="o">}</span>
</pre></div>


<p>The <code>-X</code> flag and <code>POST</code> value indicates we're performing a POST request.</p>
<p>We supply <code>-F image=@dog.jpg</code> to indicate we're submitting form encoded data. The <code>image</code> key is
then set to the contents of the <code>dog.jpg</code> file. Supplying the <code>@</code> prior to <code>dog.jpg</code> implies we
would like cURL to load the contents of the image and pass the data to the request.</p>
<p>Finally, we have our endpoint: <code>http://localhost:5000/predict</code></p>
<p>Notice how the input image is correctly classified as <em>"beagle"</em> with 99.01% confidence. The
remaining top-5 predictions and their associated probabilities and included in the response from
our Keras API as well.</p>
<hr />
<h2>Consuming the Keras REST API programmatically</h2>
<p>In all likelihood, you will be both <em>submitting</em> data to your Keras REST API and then <em>consuming</em>
the returned predictions in some manner &mdash; this requires we programmatically handle the
response from our server.</p>
<p>This is a straightforward process using the <a href="http://docs.python-requests.org/en/master/">requests</a>
Python package:</p>
<div class="highlight"><pre><span></span><span class="c1"># import the necessary packages</span>
<span class="kn">import</span> <span class="nn">requests</span>

<span class="c1"># initialize the Keras REST API endpoint URL along with the input</span>
<span class="c1"># image path</span>
<span class="n">KERAS_REST_API_URL</span> <span class="o">=</span> <span class="s2">&quot;http://localhost:5000/predict&quot;</span>
<span class="n">IMAGE_PATH</span> <span class="o">=</span> <span class="s2">&quot;dog.jpg&quot;</span>

<span class="c1"># load the input image and construct the payload for the request</span>
<span class="n">image</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">IMAGE_PATH</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">payload</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;image&quot;</span><span class="p">:</span> <span class="n">image</span><span class="p">}</span>

<span class="c1"># submit the request</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">KERAS_REST_API_URL</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="n">payload</span><span class="p">)</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

<span class="c1"># ensure the request was successful</span>
<span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]:</span>
    <span class="c1"># loop over the predictions and display them</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s2">&quot;predictions&quot;</span><span class="p">]):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{}. {}: {:.4f}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">],</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;probability&quot;</span><span class="p">]))</span>

<span class="c1"># otherwise, the request failed</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Request failed&quot;</span><span class="p">)</span>
</pre></div>


<p>The <code>KERAS_REST_API_URL</code> specifies our endpoint while the <code>IMAGE_PATH</code> is the path to our input
image residing on disk.</p>
<p>Using the <code>IMAGE_PATH</code> we load the image and then construct the <code>payload</code> to the request.</p>
<p>Given the <code>payload</code> we can POST the data to our endpoint using a call to <code>requests.post</code>.
Appending <code>.json()</code> to the end of the call instructs <code>requests</code> that:</p>
<ol>
<li>The response from the server should be in JSON</li>
<li>We would like the JSON object automatically parsed and deserialized for us</li>
</ol>
<p>Once we have the output of the request, <code>r</code>, we can check if the classification is a success
(or not) and then loop over <code>r["predictions"]</code>.</p>
<p>To run execute <code>simple_request.py</code>, first ensure <code>run_keras_server.py</code> (i.e., the Flask web server)
is currently running. From there, execute the following command in a separate shell:</p>
<div class="highlight"><pre><span></span>$ python simple_request.py
1. beagle: 0.9901
2. Walker_hound: 0.0024
3. pot: 0.0014
4. Brittany_spaniel: 0.0013
5. bluetick: 0.0011
</pre></div>


<p>We have successfully called the Keras REST API and obtained the model's predictions via Python.</p>
<hr />
<p>In this post you learned how to:</p>
<ul>
<li>Wrap a Keras model as a REST API using the <a href="http://docs.python-requests.org/en/master/">Flask web framework</a></li>
<li>Utilize cURL to send data to the API</li>
<li>Use Python and the <a href="http://docs.python-requests.org/en/master/">requests</a> package to send data
to the endpoint and consume results</li>
</ul>
<p>The code covered in this tutorial can he found <a href="https://github.com/jrosebr1/simple-keras-rest-api">here</a>
and is meant to be used as a template for your own Keras REST API &mdash; feel free to modify it as
you see fit.</p>
<p>Please keep in mind that the code in this post is meant to be <em>instructional</em>. It is <em>not</em> mean to
be production-level and capable of scaling under heavy load and a large number of incoming requests.</p>
<p>This method is best used when:</p>
<ol>
<li>You need to quickly stand up a REST API for your Keras deep learning model</li>
<li>Your endpoint is not going to be hit heavily</li>
</ol>
<p>If you're interested in a more advanced Keras REST API that leverages message queues and batching,
please refer to <a href="https://www.pyimagesearch.com/2018/01/29/scalable-keras-deep-learning-rest-api/">this blog post</a>.</p>
<p>If you have any questions or comments on this post please reach out to <a href="https://www.pyimagesearch.com/">Adrian from PyImageSearch</a>
(the author of today's post). For suggestions on future topics to cover, please find
<a href="https://twitter.com/fchollet">Francois on Twitter</a>.</p>
        </article></aside><!-- /#featured -->
                <h1>Other articles</h1>
                <hr />
                    <ol id="posts-list" class="hfeed">
        <li><article class="hentry">
                <header>
                        <h1><a href="../a-ten-minute-introduction-to-sequence-to-sequence-learning-in-keras.html" rel="bookmark" title="Permalink to A ten-minute introduction to sequence-to-sequence learning in Keras">A ten-minute introduction to sequence-to-sequence learning in Keras</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-09-29T00:00:00+02:00">
                Fri 29 September 2017
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="../author/francois-chollet.html">Francois Chollet</a>
        </address>
<p>In <a href="tutorials.html">Tutorials</a>. </p>
</p></footer><!-- /.post-info --><!-- /.post-info -->
                <p>I see this question a lot -- how to implement RNN sequence-to-sequence learning in Keras?
Here is a short introduction.</p>
<p>Note that this post assumes that you already have some experience
with recurrent networks and Keras.</p>
<hr />
<h2>What is sequence-to-sequence learning?</h2>
<p>Sequence-to-sequence learning (Seq2Seq) is about training models
to convert sequences from ...</p>
                <a class="readmore" href="../a-ten-minute-introduction-to-sequence-to-sequence-learning-in-keras.html">read more</a>
                </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header>
                        <h1><a href="../running-jupyter-notebooks-on-gpu-on-aws-a-starter-guide.html" rel="bookmark" title="Permalink to Running Jupyter notebooks on GPU on AWS: a starter guide">Running Jupyter notebooks on GPU on AWS: a starter guide</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-03-21T00:00:00+01:00">
                Tue 21 March 2017
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="../author/francois-chollet.html">Francois Chollet</a>
        </address>
<p>In <a href="tutorials.html">Tutorials</a>. </p>
</p></footer><!-- /.post-info --><!-- /.post-info -->
                <p>This is a step by step guide to start running deep learning Jupyter notebooks on an AWS GPU instance, while editing the notebooks from anywhere, in your browser. This is the perfect setup for deep learning research if you do not have a GPU on your local machine.</p>
<h2>What are ...</h2>
                <a class="readmore" href="../running-jupyter-notebooks-on-gpu-on-aws-a-starter-guide.html">read more</a>
                </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header>
                        <h1><a href="../using-pre-trained-word-embeddings-in-a-keras-model.html" rel="bookmark" title="Permalink to Using pre-trained word embeddings in a Keras model">Using pre-trained word embeddings in a Keras model</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2016-07-16T00:00:00+02:00">
                Sat 16 July 2016
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="../author/francois-chollet.html">Francois Chollet</a>
        </address>
<p>In <a href="tutorials.html">Tutorials</a>. </p>
</p></footer><!-- /.post-info --><!-- /.post-info -->
                <p>In this tutorial, we will walk you through the process of solving a text classification problem using pre-trained word embeddings and a convolutional neural network.</p>
<p>The full code for this tutorial is <a href="https://github.com/fchollet/keras/blob/master/examples/pretrained_word_embeddings.py">available on Github</a>.</p>
<p><strong>Note: all code examples have been updated to the Keras 2.0 API on March ...</strong></p>
                <a class="readmore" href="../using-pre-trained-word-embeddings-in-a-keras-model.html">read more</a>
                </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header>
                        <h1><a href="../building-powerful-image-classification-models-using-very-little-data.html" rel="bookmark" title="Permalink to Building powerful image classification models using very little data">Building powerful image classification models using very little data</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2016-06-05T00:00:00+02:00">
                Sun 05 June 2016
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="../author/francois-chollet.html">Francois Chollet</a>
        </address>
<p>In <a href="tutorials.html">Tutorials</a>. </p>
</p></footer><!-- /.post-info --><!-- /.post-info -->
                <p>In this tutorial, we will present a few simple yet effective methods that you can use to build a powerful image classifier, using only very few training examples --just a few hundred or thousand pictures from each class you want to be able to recognize. </p>
<p>We will go over the ...</p>
                <a class="readmore" href="../building-powerful-image-classification-models-using-very-little-data.html">read more</a>
                </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header>
                        <h1><a href="../building-autoencoders-in-keras.html" rel="bookmark" title="Permalink to Building Autoencoders in Keras">Building Autoencoders in Keras</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2016-05-14T00:00:00+02:00">
                Sat 14 May 2016
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="../author/francois-chollet.html">Francois Chollet</a>
        </address>
<p>In <a href="tutorials.html">Tutorials</a>. </p>
</p></footer><!-- /.post-info --><!-- /.post-info -->
                <p>In this tutorial, we will answer some common questions about autoencoders, and we will cover code examples of the following models:</p>
<ul>
<li>a simple autoencoder based on a fully-connected layer</li>
<li>a sparse autoencoder</li>
<li>a deep fully-connected autoencoder</li>
<li>a deep convolutional autoencoder</li>
<li>an image denoising model</li>
<li>a sequence-to-sequence autoencoder</li>
<li>a variational autoencoder ...</li></ul>
                <a class="readmore" href="../building-autoencoders-in-keras.html">read more</a>
                </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header>
                        <h1><a href="../keras-as-a-simplified-interface-to-tensorflow-tutorial.html" rel="bookmark" title="Permalink to Keras as a simplified interface to TensorFlow: tutorial">Keras as a simplified interface to TensorFlow: tutorial</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2016-04-24T00:00:00+02:00">
                Sun 24 April 2016
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="../author/francois-chollet.html">Francois Chollet</a>
        </address>
<p>In <a href="tutorials.html">Tutorials</a>. </p>
</p></footer><!-- /.post-info --><!-- /.post-info -->
                <h1>A complete guide to using Keras as part of a TensorFlow workflow</h1>
<p>If TensorFlow is your primary framework, and you are looking for a simple &amp; high-level model definition interface to make your life easier, this tutorial is for you.</p>
<p>Keras layers and models are fully compatible with pure-TensorFlow tensors, and ...</p>
                <a class="readmore" href="../keras-as-a-simplified-interface-to-tensorflow-tutorial.html">read more</a>
                </div><!-- /.entry-content -->
        </article></li>
</ol><!-- /#posts-list -->
</section><!-- /#content -->

        <footer id="footer" class="body">
                <address id="about" class="vcard body">
                Powered by <a href="http://alexis.notmyidea.org/pelican/">pelican</a>, which takes great advantages of <a href="http://python.org/">python</a>.
                </address><!-- /#about -->
        </footer><!-- /#footer -->

    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-61785484-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>

<!-- Mirrored from blog.keras.io/category/tutorials.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 13 Jun 2018 14:17:38 GMT -->
</html>